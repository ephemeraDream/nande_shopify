{{ 'section-product-anchor-bar.css' | asset_url | stylesheet_tag }}

<div class="product_anchor_bar_section padding-sider">
  <div class="product_anchor_bar">
    <div class="product_anchor_bar_left">
      {% for block in section.blocks %}
        <a
          class="product_anchor_bar_left_item{% if forloop.first %} active{% endif %}"
          href="#{{ block.settings.anchor_name }}"
          data-watch="{{ block.settings.anchor_name }}"
        >
          {{- block.settings.title -}}
        </a>
      {% endfor %}
    </div>
    <button class="product_anchor_bar_btn product_info_buybox_btns_btn nd-btn" data-type="buy_it_now">
      {{ 'common.jetzt_kaufen' | t }}
      {{ 'icon-right-arrow.svg' | inline_asset_content }}
    </button>
  </div>
</div>

<script>
  const links = document.querySelectorAll('.product_anchor_bar_left_item');
  const anchorBarSection = document.querySelector('.product_anchor_bar_section');
  const anchorBarParent = anchorBarSection.parentElement;
  
  // 添加sticky类
  anchorBarParent.classList.add('is-sticky');
  
  // 隐藏主导航（三部分：announcement-bar, header-simple, header-menu）
  const headerSections = document.querySelectorAll('.shopify-section-group-header-group');
  headerSections.forEach(section => {
    section.style.display = 'none';
  });
  
  // 监听滚动事件
  let isScrolling = false;
  let scrollTimeout;
  let lastScrollTop = 0;
  let anchorBarOriginalTop = 0;
  let isInitialized = false;
  
  function getAnchorBarOriginalTop() {
    if (anchorBarOriginalTop === 0) {
      const rect = anchorBarSection.getBoundingClientRect();
      anchorBarOriginalTop = rect.top + window.pageYOffset;
    }
    return anchorBarOriginalTop;
  }
  
  function handleScroll() {
    if (isScrolling) return;
    isScrolling = true;
    
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    const originalTop = getAnchorBarOriginalTop();
    
    // 添加缓冲区域，避免在边界附近闪烁
    const buffer = 10;
    
    // 如果滚动到子导航的原始位置或更上方，显示主导航，隐藏子导航
    if (scrollTop <= originalTop - buffer) {
      // 显示主导航的三部分
      headerSections.forEach(section => {
        if (section.style.display !== 'block') {
          section.style.display = 'block';
        }
      });
      if (anchorBarParent.classList.contains('is-sticky')) {
        anchorBarParent.classList.remove('is-sticky');
      }
    } else if (scrollTop > originalTop + buffer) {
      // 如果滚动超过子导航原始位置，隐藏主导航，显示子导航
      headerSections.forEach(section => {
        if (section.style.display !== 'none') {
          section.style.display = 'none';
        }
      });
      if (!anchorBarParent.classList.contains('is-sticky')) {
        anchorBarParent.classList.add('is-sticky');
      }
    }
    
    lastScrollTop = scrollTop;
    
    clearTimeout(scrollTimeout);
    scrollTimeout = setTimeout(() => {
      isScrolling = false;
    }, 16); // 约60fps
  }
  
  // 添加滚动监听
  window.addEventListener('scroll', handleScroll, { passive: true });
  
  // 初始化检查
  setTimeout(() => {
    // 只有在页面有滚动距离时才执行handleScroll
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    if (scrollTop > 0) {
      handleScroll();
    }
    isInitialized = true;
  }, 100);
  
  links.forEach((item) => {
    item.addEventListener('click', () => {
      if (item.classList.contains('active')) return;
      document.querySelector('.product_anchor_bar_left_item.active').classList.remove('active');
      item.classList.add('active');
    });
  });

  const sectionIds = Array.from(links).map((link) => link.getAttribute('data-watch'));
  let sectionsLoaded = 0;
  let sectionsObserver;
  let sections = [];

  function initializeObserver() {
    sectionIds.forEach((sectionId) => {
      waitForElement(`#${sectionId}`, (element) => {
        sections.push(element);
        sectionsLoaded++;

        if (sectionsLoaded === sectionIds.length) {
          startIntersectionObserver(sections);
        }
      });
    });
  }

  function startIntersectionObserver(sections) {
    sectionsObserver = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          const targetSection = entry.target;
          const correspondingLink = document.querySelector(
            `.product_anchor_bar_left_item[data-watch="${targetSection.id}"]`
          );
          if (entry.isIntersecting) {
            links.forEach((link) => link.classList.remove('active'));
            if (correspondingLink) {
              correspondingLink.classList.add('active');
            }
          }
        });
      },
      {
        root: null,
        threshold: 0.9,
      }
    );

    sections.forEach((section) => {
      sectionsObserver.observe(section);
    });
  }

  initializeObserver();

  function waitForElement(selector, callback) {
    const element = document.querySelector(selector);
    if (element) {
      callback(element);
      return;
    }

    const observer = new MutationObserver((mutations, obs) => {
      const element = document.querySelector(selector);
      if (element) {
        obs.disconnect();
        callback(element);
      }
    });

    observer.observe(document.body, { childList: true, subtree: true });
  }
</script>

{% schema %}
{
  "name": "product anchor bar",
  "tag": "section",
  "class": "section",
  "disabled_on": {
    "groups": ["header", "footer"]
  },
  "settings": [],
  "blocks": [
    {
      "type": "item",
      "name": "item",
      "settings": [
        {
          "type": "text",
          "id": "title",
          "label": "title"
        },
        {
          "type": "text",
          "id": "anchor_name",
          "label": "anchor name"
        }
      ]
    }
  ],
  "presets": [
    {
      "name": "product anchor bar"
    }
  ]
}
{% endschema %}
